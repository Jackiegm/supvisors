<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/doc_style.css">
    <link rel="stylesheet" href="css/menu.css">
    <title>Supervisors: A Control System for Distributed Applications</title>
</head>

<body>
	<div id="body_block">

		<div id="left_side">
			<header>
				<h1><a href="https://github.com/julien6387/supervisors" target="_blank">Supervisors</a></h1>
				<p class="version">0.1 alpha</p>
			</header>

			<nav>
				<ul>
	 				<li><a href="index.html">Introduction</a></li>
                    <li><a href="xml-rpc-api.html" class="active">XML-RPC API</a><ul>
               	        <li><a href="#status">Status</a></li>
               	        <li><a href="#supervisors">Supervisors Control</a></li>
                        <li><a href="#application">Application Control</a></li>
                        <li><a href="#process">Process Control</a></li>
                    </ul></li>
                    <li><a href="supervisorctl-api.html">supervisorctl API</a></li>
                    <li><a href="event-interface.html">Event Interface</a></li>
                    <li><a href="dashboard.html">HTTP Dashboard</a></li>
                    <li><a href="design.html">Software Design</a></li>
                </ul>
			</nav>

			<footer>
				<p>Contact: <a href="mailto:julien.6387.dev@gmail.com">Julien Le Cl&eacute;ach</a></p>
				<p id="copyright">&copy; Copyright 2016 Julien LE CLEACH</p>
			</footer>
		</div>

		<div id="right_side">
			<header>
				<h2>Documentation &raquo; XML-RPC API</h2>
			</header>

			<section id="doc-contents">
				<p>The Supervisors XML-RPC API is an extension of the Supervisor API.<br />
				Detailed information can be found in the <a href="http://supervisord.org/api.html#xml-rpc-api-documentation" class="extLink">Supervisor XML-RPC API Documentation</a>.</p>
				<p>The <strong>supervisors</strong> namespace has been added to the supervisord XML-RPC interface.</p>
				<p>The XML-RPC <code class="python">system.listMethods</code> API now provides the list of methods supported for both Supervisor and Supervisors.<br />
				An example is provided below.</p>
				<pre><code class="python">server.supervisors.getState()</code></pre>

				<p>In the following, the <em>namespec</em> refers to the full name of the process, including the application name.<br />
				For example: <code>X11:xclock</code>, where 'X11' is the name of a Supervisor group and 'xclock' is the name of a Supervisor program that is referenced in the group.<br />
				In some cases, it can also refer to all the programs of the group: <code>X11:*</code>.</p>


				<h2 id="status">Status</h2>
				<dl>
					<dt>get_api_version()</dt>
					<dd>Return the version of the RPC API used by Supervisors</dd>
					<dd>@return string: the version id</dd>

					<dt>get_supervisors_state()</dt>
					<dd>Return the state of Supervisors</dd>
					<dd>@return string: the state of Supervisors, value among { <code>'INITIALIZATION'</code>, <code>'DEPLOYMENT'</code>, <code>'OPERATION'</code>, <code>'CONCILIATION'</code> }</dd>

					<dt>get_master_address()</dt>
					<dd>Return the address of the Supervisors Master</dd>
					<dd>@return string: the IPv4 address or host name</dd>

					<dt>get_address_info(address)</dt>
					<dd>Return information about a remote supervisord managed in Supervisors and running on address</dd>
					<dd>@param string address: the address of the Supervisors instance</dd>
					<dd>@throws RPCError: with code <code>Faults.BAD_ADDRESS</code> if address is unknown to Supervisors
					<dd>@return struct: a structure containing data about the Supervisors instances
						<table>
							<tr><th>Key</th><th>Type</th><th>Unit</th><th>Validity</th><th>Description</th></tr>
							<tr><td><code>'address'</code></td><td>str</td><td></td><td></td><td>Address of the Supervisors instance.</td></tr>
							<tr><td><code>'state'</code></td><td>str</td><td></td><td><code>'UNKNOWN'</code><br /><code>'RUNNING'</code><br /><code>'SILENT'</code><br /><code>'ISOLATING'</code><br /><code>'ISOLATED'</code></td><td>State of the Supervisors instance.</td></tr>
							<tr><td><code>'remote_time'</code></td><td>int</td><td>ms</td><td></td><td>Date of the last heartbeat received from the Supervisors instance, in the remote reference time.</td></tr>
							<tr><td><code>'local_time'</code></td><td>int</td><td>ms</td><td></td><td>Date of the last heartbeat received from the Supervisors instance, in the local reference time.</td></tr>
							<tr><td><code>'loading'</code></td><td>int</td><td>%</td><td>[0;100]</td><td>Sum of the expected loading of the processes running on the address.</td></tr>
						</table>
					</dd>

					<dt>get_all_addresses_info()</dt>
					<dd>Return information about all remote supervisord managed in Supervisors</dd>
					<dd>@return list: a list of structures containing data about all remote Supervisors instances</dd>

					<dt>get_application_info(application_name)</dt>
					<dd>Return information about the application named application_name</dd>
					<dd>@param string application_name: the name of the application</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is still in state <code>INITIALIZATION</code></li>
						<li>with code <code>Faults.BAD_NAME</code> if application_name is unknown to Supervisors</li>
					</ul></dd>
					<dd>@return struct: a structure containing data about the application
						<table>
							<tr><th>Key</th><th>Type</th><th>Unit</th><th>Validity</th><th>Description</th></tr>
							<tr><td><code>'application_name'</code></td><td>str</td><td></td><td></td><td>Name of the application.</td></tr>
							<tr><td><code>'state'</code></td><td>str</td><td></td><td><code>'UNKNOWN'</code><br /><code>'STOPPED'</code><br /><code>'STARTING'</code><br /><code>'STOPPING'</code><br /><code>'RUNNING'</code></td><td>State of the application.</td></tr>
							<tr><td><code>'major_failure'</code></td><td>bool</td><td></td><td></td><td>True if at least one required process is not started.</td></tr>
							<tr><td><code>'minor_failure'</code></td><td>bool</td><td></td><td></td><td>True if at least one optional process could not be started.</td></tr>
						</table>
					</dd>

					<dt>get_all_applications_info()</dt>
					<dd>Return information about all applications managed in Supervisors</dd>
					<dd>@throws RPCError: with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is still in state <code>INITIALIZATION</code></dd>
					<dd>@return list: a list of structures containing data about all applications</dd>

					<dt>get_process_info(namespec)</dt>
					<dd>Return information about the process named namespec<br />
					It is a complement of supervisor ProcessInfo by telling where the process is running</dd>
					<dd>@param string namespec: the process name (or 'group:name', or 'group:*')</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is still in state <code>INITIALIZATION</code></li>
						<li>with code <code>Faults.BAD_NAME</code> if namespec is unknown to Supervisors</li>
					</ul></dd>
					<dd>@return list: a list of structures containing data about the processes
						<table>
							<tr><th>Key</th><th>Type</th><th>Unit</th><th>Validity</th><th>Description</th></tr>
							<tr><td><code>'process_name'</code></td><td>str</td><td></td><td></td><td>Namespec of the process.</td></tr>
							<tr><td><code>'state'</code></td><td>str</td><td></td><td></td><td>State of the process.</td></tr>
							<tr><td><code>'address'</code></td><td>list(str)</td><td></td><td></td><td>List of all addresses where the process is running.<br />
							If more than one element in list, consider that a conflict is in progress.</td></tr>
						</table>
					</dd>

					<dt>get_process_rules(namespec)</dt>
					<dd>Return the rules used to deploy the process named namespec</dd>
					<dd>@param string namespec: the process name (or 'group:name', or 'group:*')</dd>
					<dd>@throws RPCError: with code <code>Faults.BAD_NAME</code> if namespec is unknown to Supervisors</dd>
					<dd>@return list: a list of structures containing data about the deployment rules
						<table>
							<tr><th>Key</th><th>Type</th><th>Unit</th><th>Validity</th><th>Description</th></tr>
							<tr><td><code>'process_name'</code></td><td>str</td><td></td><td></td><td>Namespec of the process.</td></tr>
							<tr><td><code>'addresses'</code></td><td>list(str)</td><td></td><td></td><td>List of all addresses where the process can be started.</td></tr>
							<tr><td><code>'start_sequence'</code></td><td>int</td><td></td><td>[0;127]</td><td>Starting order of the process when starting the related application.</td></tr>
							<tr><td><code>'stop_sequence'</code></td><td>int</td><td></td><td>[0;127]</td><td>Stopping order of the process when stopping the related application.</td></tr>
							<tr><td><code>'required'</code></td><td>bool</td><td></td><td></td><td>Importance of the process in the application.</td></tr>
							<tr><td><code>'wait_exit'</code></td><td>bool</td><td></td><td></td><td>True if Supervisors has to wait for the process to exit before triggering the next deployment phase.</td></tr>
							<tr><td><code>'loading'</code></td><td>int</td><td></td><td>[0;100]</td><td>Expected loading of the process when <code>RUNNING</code>.</td></tr>
						</table>
					</dd>

					<dt>get_conflicts()</dt>
					<dd>Return the conflicting processes</dd>
					<dd>@return list: a list of structures containing data about the conflicting processes
						<table>
							<tr><th>Key</th><th>Type</th><th>Unit</th><th>Validity</th><th>Description</th></tr>
							<tr><td><code>'process_name'</code></td><td>str</td><td>Namespec of the process.</td></tr>
							<tr><td><code>'state'</code></td><td>str</td><td>State of the process.</td></tr>
							<tr><td><code>'address'</code></td><td>list(str)</td><td>List of all addresses where the process is running.<br />
							If more than one element in list, consider that a conflict is in progress.</td></tr>
						</table>
					</dd>
				</dl>


				<h2 id="supervisors">Supervisors Control</h2>
				<dl>
					<dt>restart()</dt>
					<dd>Restart Supervisors through all remote Supervisor instances</dd>
					<dd>@return boolean: always True unless error</dd>

					<dt>shutdown()</dt>
					<dd>Shut down Supervisors through all remote Supervisor instances</dd>
					<dd>@return boolean: always True unless error</dd>
				</dl>


				<h2 id="application">Application Control</h2>
				<dl>
					<dt>start_application(strategy, application_name, wait=True)</dt>
					<dd>Start the processes related to the application named application_name in accordance with the strategy and the rules defined in the deployment file</dd>
					<dd>@param DeploymentStrategies strategy: the strategy to use for choosing an address</dd>
					<dd>@param string application_name: the name of the application</dd>
					<dd>@param boolean wait: wait for the application to be fully started</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is not in state <code>OPERATION</code></li>
						<li>with code <code>Faults.BAD_STRATEGY</code> if strategy is unknown to Supervisors</li>
						<li>with code <code>Faults.BAD_NAME</code> if application_name is unknown to Supervisors</li>
						<li>with code <code>Faults.ALREADY_STARTED</code> if application is <code>RUNNING</code></li>
						<li>with code <code>Faults.ABNORMAL_TERMINATION</code> if application could not be started</li>
					</ul></dd>
					<dd>@return boolean: always True unless error or nothing to start</dd>

					<dt>stop_application(application_name, wait=True)</dt>
					<dd>Stop the running processes related to the application named application_name</dd>
					<dd>@param string application_name: the name of the application</dd>
					<dd>@param boolean wait: wait for the application to be fully stopped</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code>
                        if Supervisors is not in state <code>OPERATION</code> or <code>CONCILIATION</code></li>
						<li>with code <code>Faults.BAD_NAME</code> if application_name is unknown to Supervisors</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>

					<dt>restart_application(strategy, application_name, wait=True)</dt>
					<dd>Restart the processes related to the application named application_name in accordance with the strategy and the rules defined in the deployment file</dd>
					<dd>@param DeploymentStrategies strategy: the strategy to use for choosing an address</dd>
					<dd>@param string application_name: the name of the application</dd>
					<dd>@param boolean wait: wait for the application to be fully restarted</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is not in state <code>OPERATION</code></li>
						<li>with code <code>Faults.BAD_STRATEGY</code> if strategy is unknown to Supervisors</li>
						<li>with code <code>Faults.BAD_NAME</code> if application_name is unknown to Supervisors</li>
						<li>with code <code>Faults.ALREADY_STARTED</code> if application is <code>RUNNING</code></li>
						<li>with code <code>Faults.ABNORMAL_TERMINATION</code> if application could not be started</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>
				</dl>


				<h2 id="process">Process Control</h2>
				<dl>
					<dt>start_args(namespec, extra_args=None, wait=True)</dt>
					<dd>Start a process upon request of the Deployer of Supervisors<br />
        			The behaviour is different from <code class="python">supervisor.startProcess</code> as it sets the process state to FATAL instead of throwing an exception to the RPC client<br />
                    In addition to that, it is possible to pass extra arguments to the command line</dd>
					<dd>@param string namespec: the process name</dd>
					<dd>@param string extra_args: the additional arguments to be passed to the command line</dd>
					<dd>@param boolean wait: wait for the process to be fully started</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_NAME</code> if namespec is unknown to the local Supervisor</li>
						<li>with code <code>Faults.BAD_EXTRA_ARGUMENTS</code> if program is required or has a start sequence</li>
						<li>with code <code>Faults.ALREADY_STARTED</code> if process is <code>RUNNING</code></li>
						<li>with code <code>Faults.ABNORMAL_TERMINATION</code> if process could not be started</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>

					<dt>start_process(strategy, namespec, extra_args=None, wait=True)</dt>
					<dd>Start the process named namespec in accordance with the strategy and the rules defined in the deployment file<br />
                    Additional arguments can be passed to the command line using the extra_ags parameter.<br />
					WARN: the 'wait_exit' rule is not considered here</dd>
					<dd>@param DeploymentStrategies strategy: the strategy to use for choosing an address</dd>
					<dd>@param string namespec: the process name (or 'group:name', or 'group:*')</dd>
					<dd>@param string extra_args: the additional arguments to be passed to the command line</dd>
					<dd>@param boolean wait: wait for the process to be fully started</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is not in state <code>OPERATION</code></li>
						<li>with code <code>Faults.BAD_STRATEGY</code> if strategy is unknown to Supervisors</li>
						<li>with code <code>Faults.BAD_NAME</code> if namespec is unknown to Supervisors</li>
						<li>with code <code>Faults.ALREADY_STARTED</code> if process is <code>RUNNING</code></li>
						<li>with code <code>Faults.ABNORMAL_TERMINATION</code> if process could not be started</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>

					<dt>stop_process(namespec, wait=True)</dt>
					<dd>Stop the process named namespec where it is running</dd>
					<dd>@param string namespec: the process name (or 'group:name', or 'group:*')</dd>
					<dd>@param boolean wait: wait for the process to be fully stopped</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code>
                        if Supervisors is not in state <code>OPERATION</code> or <code>CONCILIATION</code></li>
						<li>with code <code>Faults.BAD_NAME</code> if namespec is unknown to Supervisors</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>

					<dt>restart_process(strategy, namespec, wait=True)</dt>
					<dd>Stop the process named namespec where it is running and restart it in accordance with the strategy and the rules defined in the deployment file<br />
					WARN: the 'wait_exit' rule is not considered here</dd>
					<dd>@param DeploymentStrategies strategy: the strategy to use for choosing an address</dd>
					<dd>@param string namespec: the process name (or 'group:name', or 'group:*')</dd>
					<dd>@param boolean wait: wait for the process to be fully restarted</dd>
					<dd>@throws RPCError:<ul>
						<li>with code <code>Faults.BAD_SUPERVISORS_STATE</code> if Supervisors is not in state <code>OPERATION</code></li>
						<li>with code <code>Faults.BAD_STRATEGY</code> if strategy is unknown to Supervisors</li>
						<li>with code <code>Faults.BAD_NAME</code> if namespec is unknown to Supervisors</li>
						<li>with code <code>Faults.ALREADY_STARTED</code> if process is <code>RUNNING</code></li>
						<li>with code <code>Faults.ABNORMAL_TERMINATION</code> if process could not be started</li>
					</ul></dd>
					<dd>@return boolean: always True unless error</dd>
				</dl>

			</section>

		</div>
	</div>
</body>
</html>

